@startuml
title IaC ↔ IaaS Interface (Detailed) — GPU Analytics Stack

skinparam shadowing false
skinparam componentStyle rectangle

' -------------------- IaC Layer --------------------
package "IaC" as IAC {
  component TF   as "Terraform"
  component PKR  as "Packer"
  component ANS  as "Ansible"
  component CI   as "CI/CD (fmt/lint/plan/apply)"
  component RS   as "Remote State (S3+DDB)"
}
note right of TF
- Declarative modules
- Providers: aws, kubernetes
- Plan → Apply with review
- tfsec/tflint/pre-commit
end note
note right of PKR
- Bake immutable AMIs
- NVIDIA driver + CUDA
- Docker + nvidia toolkit
- DCGM exporter
end note
note right of ANS
- Idempotent converge
- Drivers sanity (nvidia-smi)
- Agents/sysctls/limits
- Inventory from TF outputs
end note
note right of RS
- S3 backend per env
- DynamoDB state lock
- Workspaces for dev/stg/prod
end note

CI --> TF : run fmt/lint/plan/apply
TF --> RS : backend

' -------------------- IaaS Layer --------------------
package "IaaS (AWS)" as IAAS {
  node   VPC  as "VPC/Subnets/Routes/SG"
  node   EKS  as "EKS (control plane)"
  node   LTG  as "Launch Template (GPU)"
  node   LTN  as "Launch Template (Gen)"
  node   ASGG as "ASG (GPU nodes)"
  node   ASGN as "ASG (General nodes)"
  node   MSK  as "MSK or EC2 Kafka"
  database ST  as "EBS/EFS/FSx"
  component IAM as "IAM Roles/IRSA/Profiles"
  component KMS as "KMS Keys"
  component SSM as "SSM/Param Store/Secrets"
  component CW   as "CloudWatch Logs/Metrics"
  component AMI  as "GPU AMI"
}

' -------------------- Provisioning Flows --------------------
TF --> VPC : create
TF --> EKS : create
TF --> ST  : storage classes/CSI prereqs
TF --> IAM : roles, instance profiles, IRSA
TF --> SSM : params/secrets (ARNs)
TF --> KMS : key refs for EBS/params
TF --> MSK : cluster or EC2 brokers

PKR --> AMI : register AMI
TF --> LTG : set image=user AMI
TF --> LTN : set image=base AMI
LTG --> ASGG : launch config
LTN --> ASGN : launch config
TF --> ASGG : scaling min/max/desired
TF --> ASGN : scaling min/max/desired

' -------------------- Runtime/Wiring --------------------
ASGG --> EKS : join as GPU nodegroup
ASGN --> EKS : join as general nodegroup
ANS --> ASGG : converge via SSM Session
SSM --> ASGG : agent, commands
CW  --> ASGG : logs/metrics shipping

' -------------------- Notes on the Interface --------------------
note right of LTG
Launch Template (GPU):
- References baked AMI
- User data: cloud-init
- Labels/taints for k8s
- EBS gp3/io2 policy
end note

note right of ASGG
ASG (GPU):
- MixedInstances (Spot/OD)
- capacity-optimized strategy
- Health checks + replace
- Scaled by Autoscaler/Karpenter
end note

note right of IAM
IAM/IRSA:
- Node instance profiles
- Pod roles via IRSA
- Least-privilege policies
end note

note right of SSM
SSM/Secrets:
- Param Store/Secrets Manager
- Session Manager (no SSH)
- Encrypted with KMS
end note

note right of EKS
EKS:
- Control plane only
- Nodegroups from ASGs
- CNI/CSI add-ons via IaC
end note

note right of MSK
Kafka:
- Prefer MSK to reduce ops
- If EC2 brokers: pin SGs,
  EBS IO, OS tuning
end note

note bottom
Contract between IaC and IaaS:
- Terraform owns desired state of VPC/EKS/ASGs/roles/storage
- Packer owns AMI immutability (drivers/runtime baked)
- Ansible owns node convergence post-boot (minimal drift)
- Runtime telemetry and access via CloudWatch + SSM
end note

@enduml
