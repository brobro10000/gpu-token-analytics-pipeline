@startuml
title IaC <-> IaaS Interface (Detailed, Taller Layout)

skinparam shadowing false
skinparam componentStyle rectangle
skinparam defaultTextAlignment left
skinparam nodesep 70
skinparam ranksep 100

' ===================== IaC Layer =====================
package "IaC" as IAC {
  component TF   as "Terraform"
  component PKR  as "Packer"
  component ANS  as "Ansible"
  component CI   as "CI/CD (fmt/lint/plan/apply)"
  component RS   as "Remote State (S3 + DynamoDB)"
}

note bottom of TF
- Declarative modules
- Providers: aws, kubernetes
- Plan -> Apply with review
- tfsec / tflint / pre-commit
end note

note bottom of PKR
- Bake immutable AMIs
- NVIDIA driver + CUDA
- Docker + nvidia toolkit
- DCGM exporter
end note

note bottom of ANS
- Idempotent converge
- Driver sanity (nvidia-smi)
- Agents / sysctls / limits
- Inventory from TF outputs
end note

note bottom of RS
- S3 backend per env
- DynamoDB state lock
- Workspaces: dev / stg / prod
end note

CI --> TF : run fmt/lint/plan/apply
TF --> RS : backend

' ===================== IaaS Layer (stacked) =====================
package "IaaS (AWS)" as IAAS {

  package "Networking" as NET {
    node VPC  as "VPC / Subnets / Routes / SG"
  }
  note bottom of NET
  Private/public subnets, NAT/IGW, SGs, optional flow logs
  end note

  package "Compute - Control" as CTRL {
    node EKS  as "EKS (control plane)"
  }
  note bottom of CTRL
  K8s control plane; nodegroups attach via ASGs
  end note

  package "Compute - Images & Templates" as IMG {
    component AMI  as "Base or GPU AMI"
    node   LTG     as "Launch Template (GPU)"
    node   LTN     as "Launch Template (General)"
  }
  note bottom of IMG
  AMI from Packer; templates define image, userdata, tags, EBS defaults
  end note

  package "Compute - Node Groups" as NODES {
    node   ASGG as "ASG (GPU nodes)"
    node   ASGN as "ASG (General nodes)"
  }
  note bottom of NODES
  Health checks, replace, mixed instances (Spot/On-Demand), scaling policies
  end note

  package "Platform Services" as PLAT {
    node   MSK  as "MSK or EC2 Kafka"
  }
  note bottom of PLAT
  Prefer MSK to reduce ops; EC2 brokers need SGs, EBS IO, OS/network tuning
  end note

  package "Storage" as STOR {
    database ST  as "EBS / EFS / FSx"
  }
  note bottom of STOR
  EBS gp3/io2 throughput/IOPS; EFS for shared POSIX; FSx for high-perf
  end note

  package "Identity & Secrets" as IDSEC {
    component IAM as "IAM Roles / IRSA / Profiles"
    component SSM as "SSM / Param Store / Secrets"
    component KMS as "KMS Keys"
  }
  note bottom of IDSEC
  Least privilege; IRSA for pods; SSM for access (no SSH); KMS for encryption
  end note

  package "Observability" as OBS {
    component CW   as "CloudWatch Logs / Metrics"
  }
  note bottom of OBS
  Ship node/app logs and metrics; alarms for scaling and health
  end note
}

' ===================== Provisioning Flows =====================
TF --> VPC  : create networking
TF --> EKS  : create control plane
TF --> ST   : storage classes / CSI prereqs
TF --> IAM  : roles / instance profiles / IRSA
TF --> SSM  : params / secrets (ARNs)
TF --> KMS  : key policies / grants
TF --> MSK  : cluster or EC2 brokers

PKR --> AMI : register AMI
TF --> LTG  : set image = user AMI
TF --> LTN  : set image = base AMI
LTG --> ASGG : launch config
LTN --> ASGN : launch config
TF --> ASGG : min / max / desired
TF --> ASGN : min / max / desired

' ===================== Runtime / Wiring =====================
ASGG --> EKS : join as GPU nodegroup
ASGN --> EKS : join as general nodegroup
ANS  --> ASGG : converge via SSM Session
SSM  --> ASGG : session / commands
CW   --> ASGG : logs / metrics shipping

' ===================== Interface Contract =====================
note bottom
Contract:
- Terraform owns desired state of VPC/EKS/ASGs/roles/storage
- Packer owns AMI immutability (drivers/runtime baked)
- Ansible owns node convergence post-boot (minimal drift)
- Runtime telemetry and access via CloudWatch + SSM
end note

@enduml
