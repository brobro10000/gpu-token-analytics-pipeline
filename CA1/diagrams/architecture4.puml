@startuml
title IaC ↔ IaaS Interface (Collapsed GPU) — Provisioning Essentials

skinparam shadowing false
skinparam componentStyle rectangle

' -------------------- IaC Layer --------------------
package "IaC" as IAC {
  component TF   as "Terraform"
  component PKR  as "Packer (base AMIs)"
  component ANS  as "Ansible (converge)"
  component CI   as "CI/CD (fmt/lint/plan/apply)"
  component RS   as "Remote State (S3 + DynamoDB)"
}
note right of IAC
IaC Responsibilities:
- TF: declarative infra, modules, plans
- PKR: immutable AMIs (base OS, agents)
- ANS: idempotent host config
- CI: gates, policy, plans
- RS: backend + locking
end note

CI --> TF : run pipelines
TF --> RS : backend/lock

' -------------------- IaaS Layer (Collapsed Compute) --------------------
package "IaaS (AWS)" as IAAS {
  node   VPC  as "VPC / Subnets / Routes / SG"
  node   LT_A as "Launch Template (App)"
  node   ASG_A as "Auto Scaling Group (App Nodes)"
  node   EKS  as "EKS (optional)"
  node   MSK  as "MSK (or EC2 Kafka) [opt]"
  database ST as "EBS / EFS / FSx"
  component IAM as "IAM Roles / IRSA / Profiles"
  component SSM as "SSM / Param Store / Secrets"
  component KMS as "KMS Keys"
  component CW  as "CloudWatch Logs / Metrics"
  component AMI as "Base AMI (from Packer)"
}

' -------------------- Provisioning Flows --------------------
TF --> VPC  : create network
TF --> IAM  : roles, policies, profiles
TF --> SSM  : params / secrets (refs)
TF --> KMS  : key policies
TF --> ST   : storage classes / CSI prereqs
TF --> MSK  : cluster (or EC2 brokers)
TF --> EKS  : control plane (if used)

PKR --> AMI : register AMI
TF --> LT_A : set image = Base AMI
LT_A --> ASG_A : launch config
TF --> ASG_A : min/max/desired + lt

' -------------------- Runtime Wiring --------------------
ASG_A --> EKS : join as nodegroup (if EKS used)
ANS --> ASG_A : converge via SSM
SSM --> ASG_A : session/commands
CW  --> ASG_A : logs/metrics ship

' -------------------- Notes on Each Segment --------------------
note right of VPC
Networking:
- Private/public subnets
- NAT/IGW as needed
- Security Groups, NACLs
- Flow logs (optional)
end note

note right of IAM
Identity:
- Instance profiles for nodes
- IRSA for pods (fine-grained)
- Least-privilege policies
end note

note right of SSM
Secrets/Access:
- Param Store & Secrets Manager
- Session Manager (no SSH)
- Encrypted at rest (KMS)
end note

note right of KMS
Encryption:
- EBS, S3, SSM key usage
- Key rotation & grants
- Boundary policies (opt)
end note

note right of ST
State & Volumes:
- EBS gp3/io2 (throughput/IOPS)
- EFS for shared POSIX
- FSx for high-perf workloads
end note

note right of MSK
Messaging:
- Prefer MSK to reduce ops
- If EC2 brokers: pin SGs,
  tune disks/net, set quotas
end note

note right of EKS
Orchestration (optional):
- Control plane only
- Nodegroups from ASG
- CNI/CSI add-ons via IaC
end note

note right of LT_A
Launch Template:
- AMI, user-data, tags
- Instance profile
- EBS defaults, metadata opts
end note

note right of ASG_A
Scaling Group:
- Health checks, replace
- Mixed instances (Spot/OD)
- Target tracking policies
end note

note bottom
Contract:
- Terraform owns desired state for network, identity, storage, scaling, and optional EKS/MSK
- Packer owns AMI immutability (base OS + agents/tools)
- Ansible owns minimal post-boot convergence (only what is not baked)
- SSM/CW provide access and telemetry without SSH
end note

@enduml
